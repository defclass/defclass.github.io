<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2025-10-07 Tue 21:18 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Clojure 如何表达 OOP 设计模式</title>
<meta name="author" content="Michael Wong" />
<meta name="generator" content="Org Mode" />

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="author" content="Michael Wong">
<meta name="description" content="My blog">
<meta name="language" content="en">
<link rel="icon" type="image/x-icon" href="/assets/favicon.ico">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400&display=swap" rel="stylesheet">
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="stylesheet" href="/assets/css/highlight.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="/assets/js/main.js" defer></script>
</head>
<body>
<div id="preamble" class="status">

<header class="site-header">
  <div class="container">
    <h1 class="site-title"><a href="/">Michael Wong's blog</a></h1>
    <nav class="site-nav">
      <a href="/">Home</a>
      <a href="/archive.html">Archive</a>
    </nav>
  </div>
</header>
</div>
<div id="content" class="content">
<header>
<h1 class="title">Clojure 如何表达 OOP 设计模式</h1>
</header><p>
近几年的工作都是写 Clojure ，大多数时间是用函数式编程风格。 OOP 的设计模式在函数式语言里显得非常轻量，有时根本意识不到有些用法是设计模式。简单聊一聊，常用的设计模式在 Clojure 里可能长什么样子。由于语言类型不同，一些和语言构件相关的模式在 Clojure 里不太需要，比如我在写 Clojure 时就很少需要用迭代器模式。
</p>

<p>
对象是 OOP 编程语言中的一等公民，在函数式语言中函数是编程中的一等公民，所以下面有些地方我会直接用函数来代替对象，如工厂模式用生产函数来代替生产对象。
</p>
<div id="outline-container-orge8ca342" class="outline-2">
<h2 id="orge8ca342"><span class="section-number-2">1.</span> 策略模式</h2>
<div class="outline-text-2" id="text-1">
<p>
定义：策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #A52A2A; font-weight: bold;">defn</span> <span style="color: #00578E; font-weight: bold;">quack</span> [] (println <span style="color: #4E9A06;">"quack"</span>))
(<span style="color: #A52A2A; font-weight: bold;">defn</span> <span style="color: #00578E; font-weight: bold;">squeak</span> [] (println <span style="color: #4E9A06;">"squeak"</span>))

(<span style="color: #A52A2A; font-weight: bold;">defn</span> <span style="color: #00578E; font-weight: bold;">make-sound</span> [duck?]
  (<span style="color: #A52A2A; font-weight: bold;">let</span> [sound-f (<span style="color: #A52A2A; font-weight: bold;">if</span> duck? quack squeak)]
    (sound-f)))

(make-sound <span style="color: #F5666D;">true</span>)
</pre>
</div>

<p>
小辨析：
</p>

<p>
策略模式：在 context 对象主动指定哪个策略对象来执行动作。
</p>

<p>
状态模式：在 context 对象中的状态决定使用哪一个 state 状态对象来操作，state 状态对象在执行操作中反过来会改变 context 对象中的状态。
</p>
</div>
</div>
<div id="outline-container-org5d406e9" class="outline-2">
<h2 id="org5d406e9"><span class="section-number-2">2.</span> 单件模式</h2>
<div class="outline-text-2" id="text-2">
<p>
定义：确保一个类只有一个实例，并提供一个全局访问点。
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #A52A2A; font-weight: bold;">let</span> [conn (<span style="color: #A52A2A; font-weight: bold;">delay</span> (create-conn))]
 (<span style="color: #A52A2A; font-weight: bold;">defn</span> <span style="color: #00578E; font-weight: bold;">get-instance</span> [] @conn))
(get-instance)
</pre>
</div>
</div>
</div>
<div id="outline-container-orge60b3ab" class="outline-2">
<h2 id="orge60b3ab"><span class="section-number-2">3.</span> 工厂模式</h2>
<div class="outline-text-2" id="text-3">
<p>
定义:  定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #A52A2A; font-weight: bold;">defn</span> <span style="color: #00578E; font-weight: bold;">create-adder</span>
  [n]
  (<span style="color: #A52A2A; font-weight: bold;">fn</span> [x]
    (+ n x)))

(map (<span style="color: #A52A2A; font-weight: bold;">fn</span> [x] (create-adder x))
  (range 10))
</pre>
</div>

<p>
抽象工厂模式在 Clojure 中似乎和工厂模式没有太多区别。
</p>
</div>
</div>
<div id="outline-container-orgc0fb746" class="outline-2">
<h2 id="orgc0fb746"><span class="section-number-2">4.</span> 装饰者模式</h2>
<div class="outline-text-2" id="text-4">
<p>
定义：动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。
</p>

<p>
Clojure 类型继承很弱，依然以函数来实现。
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #A52A2A; font-weight: bold;">defn</span> <span style="color: #00578E; font-weight: bold;">origin</span> [n] n)

(<span style="color: #A52A2A; font-weight: bold;">defn</span> <span style="color: #00578E; font-weight: bold;">decorator</span>
  <span style="color: #4E9A06;">"add 5"</span>
  [f]
  (<span style="color: #A52A2A; font-weight: bold;">fn</span> [n]
    (+ (f n) 5)))

(<span style="color: #A52A2A; font-weight: bold;">def</span> <span style="color: #0084C8; font-weight: bold;">new-f</span> (decorator origin))
(new-f 3)
</pre>
</div>

<p>
小辨析：
</p>

<p>
装饰者：装饰与被装饰者实现同一个接口，在同一个接口内增强功能。
</p>

<p>
适配器：适配与被适配者实现的是两个不同的接口。意图是改变接口，满足客户的期望。
</p>

<p>
外观模式：用一个接口实现子系统的一群接口。意图是，提供子系统的一个简化接口。
</p>
</div>
</div>
<div id="outline-container-org33091c6" class="outline-2">
<h2 id="org33091c6"><span class="section-number-2">5.</span> 观察者模式</h2>
<div class="outline-text-2" id="text-5">
<p>
定义：定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #A52A2A; font-weight: bold;">def</span> <span style="color: #0084C8; font-weight: bold;">subject</span> (atom <span style="color: #F5666D;">nil</span>))

(<span style="color: #A52A2A; font-weight: bold;">defn</span> <span style="color: #00578E; font-weight: bold;">subscribe</span> [key ref old-state new-state]
  (print <span style="color: #4E9A06;">"Current val is "</span> new-state))

(add-watch subject <span style="color: #F5666D;">:sub</span> subscribe)
(reset! subject {<span style="color: #F5666D;">:foo</span> <span style="color: #4E9A06;">"bar"</span>})
(remove-watch subject <span style="color: #F5666D;">:sub</span>)
</pre>
</div>
</div>
</div>
<div id="outline-container-org3af2d53" class="outline-2">
<h2 id="org3af2d53"><span class="section-number-2">6.</span> 命令模式</h2>
<div class="outline-text-2" id="text-6">
<p>
定义：将"请求"封装成对象，调用方可以直接调用对象的 execute。命令模式也支持可撤销的操作。
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #A52A2A; font-weight: bold;">def</span> <span style="color: #0084C8; font-weight: bold;">command1</span> (<span style="color: #A52A2A; font-weight: bold;">fn</span> [] (print <span style="color: #4E9A06;">"command1"</span>)))
(<span style="color: #A52A2A; font-weight: bold;">def</span> <span style="color: #0084C8; font-weight: bold;">command2</span> (<span style="color: #A52A2A; font-weight: bold;">fn</span> [] (print <span style="color: #4E9A06;">"command2"</span>)))

(<span style="color: #A52A2A; font-weight: bold;">doseq</span> [cmd [command1 command2]]
  (cmd))
</pre>
</div>

<p>
小辨析：
</p>

<p>
策略模式：在调用方需要传入一致的参数.
</p>

<p>
命令模式：将不同命令的参数封装在命令对象里，只留一个 execute 方法。
</p>
</div>
</div>
<div id="outline-container-org4ce18b3" class="outline-2">
<h2 id="org4ce18b3"><span class="section-number-2">7.</span> 适配器模式</h2>
<div class="outline-text-2" id="text-7">
<p>
定义：适配器模式，将一个类的接口，转换成客户期望的另一个接口。
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #A52A2A; font-weight: bold;">defn</span> <span style="color: #00578E; font-weight: bold;">add</span> [x y] (+ x y))

(<span style="color: #A52A2A; font-weight: bold;">defn</span> <span style="color: #00578E; font-weight: bold;">adopter</span> [x y]
  (add (<span style="color: #2F8B58; font-weight: bold;">Integer</span>/parseInt x) (<span style="color: #2F8B58; font-weight: bold;">Integer</span>/parseInt y)))

(adopter <span style="color: #4E9A06;">"1"</span> <span style="color: #4E9A06;">"2"</span>)
</pre>
</div>

<p>
小辨析：
</p>

<p>
装饰者：装饰与被装饰者实现同一个接口，在同一个接口内增强功能。
</p>

<p>
适配器：适配与被适配者实现的是两个不同的接口。意图是改变接口，满足客户的期望。
</p>

<p>
外观模式：用一个接口实现子系统的一群接口。意图是，提供子系统的一个简化接口。
</p>
</div>
</div>
</div>
<div id="postamble" class="status">

<footer class="site-footer">
  <div class="container">
    <p>&copy; Michael Wong. All rights reserved.</p>
  </div>
</footer>
</div>
</body>
</html>
